diff --git a/inc/api_graphics.hpp b/inc/api_graphics.hpp
index e8d05e4..cd3a487 100644
--- a/inc/api_graphics.hpp
+++ b/inc/api_graphics.hpp
@@ -100,6 +100,7 @@ private:
 	std::vector<VkFence> in_flight_fences;
 	std::vector<VkFence> images_in_flight;
 	
+	mem::Memory shadow_pass_texture;
 	mem::Memory depth_memory;
 
 	std::unique_ptr<mem::Pool> ubo_pool;
@@ -134,9 +135,11 @@ private:
 	void create_swapchain();
 	void create_depth_resources();
 	void create_frame_buffers();
+	void create_depth_buffer();
 	void create_colour_image_views();
 	void create_texture_sampler();
 	void create_render_pass();
+	void create_shadowpass();
 	VkShaderModule create_shader_module(std::vector<char> shaderCode);
 	std::vector<char> read_file(const std::string& filename);
 	VkPipelineShaderStageCreateInfo fill_shader_stage_struct(VkShaderStageFlagBits stage, VkShaderModule shaderModule);
diff --git a/inc/memory_allocator.hpp b/inc/memory_allocator.hpp
index 53d59a2..bfcae4b 100644
--- a/inc/memory_allocator.hpp
+++ b/inc/memory_allocator.hpp
@@ -18,6 +18,43 @@
 
 namespace mem {
 
+struct BufferCreateInfo {
+    const void* pNext = nullptr;
+    VkBufferCreateFlags flags = 0;
+    VkDeviceSize size;
+    VkBufferUsageFlags usage;
+    VkSharingMode sharingMode;
+    uint32_t queueFamilyIndexCount;
+    const uint32_t* pQueueFamilyIndices;
+    VkMemoryPropertyFlags memoryProperties;
+};
+
+class Image {
+
+};
+
+class SearchBuffer {
+
+};
+
+class StackBuffer {
+private:
+    VkDeviceSize buffer_size;
+    VkDeviceSize offset;
+    VkDeviceMemory buffer_memory;
+    VkBuffer buffer;
+    //offset = i * allocations[i]   
+    std::vector<VkDeviceSize> allocations;
+public:
+    StackBuffer(VkPhysicalDevice physical_device, VkDevice device, BufferCreateInfo* p_buffer_info);
+    ~StackBuffer();
+
+public:
+    void destroy();
+    VkDeviceSize allocate(VkDeviceSize allocation_size);
+    void free(VkDeviceSize delete_offset);
+};
+
 struct PoolCreateInfo {
     uint32_t pool_size;
     VkDescriptorType set_type; 
@@ -57,18 +94,6 @@ struct MemoryInfo {
 
 };
 
-struct BufferCreateInfo {
-    const void* pNext = nullptr;
-    VkBufferCreateFlags flags = 0;
-    VkDeviceSize size;
-    VkBufferUsageFlags usage;
-    VkSharingMode sharingMode;
-    uint32_t queueFamilyIndexCount;
-    const uint32_t* pQueueFamilyIndices;
-
-    VkMemoryPropertyFlags memoryProperties;
-};
-
 struct Space {
     VkDeviceSize offset;
     VkDeviceSize size;
diff --git a/inc/world_objects.hpp b/inc/world_objects.hpp
index 70b6a98..256d7ab 100644
--- a/inc/world_objects.hpp
+++ b/inc/world_objects.hpp
@@ -51,6 +51,7 @@ private:
 public:
 	~GameObject();
 	void add_mesh(const std::string& fileName);
+	void scale(glm::vec3 scale_vector);
 };
 
 }
\ No newline at end of file
diff --git a/lib/api_graphics.cpp b/lib/api_graphics.cpp
index e3c50da..713bd51 100644
--- a/lib/api_graphics.cpp
+++ b/lib/api_graphics.cpp
@@ -80,10 +80,6 @@ void GraphicsImpl::update_draw(std::vector<GameObject*> game_objects) {
 
 			for (size_t j = 0; j < meshes.size(); j++) {
 				//for now lets just assume this works so we can deal with the other errors...
-				for (size_t l = 0; l < meshes[j]->indices.size(); l++) {
-					printf("index_data: | %u |", meshes[j]->indices[l]);
-				}
-				printf("\n");
 				update_vertex_buffer(meshes[j]->vertices);
 				update_index_buffer(meshes[j]->indices);
 
diff --git a/lib/game_objects.cpp b/lib/game_objects.cpp
index 4696167..c6bea95 100644
--- a/lib/game_objects.cpp
+++ b/lib/game_objects.cpp
@@ -19,3 +19,14 @@ void GameObject::add_mesh(const std::string& file_name) {
 	changed = 1;
 	object_model.add_mesh(file_name);
 }
+
+void GameObject::scale(glm::vec3 scale_vector) {
+	glm::mat4 scale_mat = {
+		scale_vector.x, 0, 0, 0,
+		0, scale_vector.y, 0, 0,
+		0, 0, scale_vector.z, 0,
+		0, 0, 0, 1
+	};
+
+	transform = transform * scale_mat;
+}
diff --git a/lib/graphics_draw.cpp b/lib/graphics_draw.cpp
index 4144128..0901c7e 100644
--- a/lib/graphics_draw.cpp
+++ b/lib/graphics_draw.cpp
@@ -44,6 +44,15 @@ void GraphicsImpl::create_texture_sampler() {
     }
 }
 
+void GraphicsImpl::create_depth_buffer() {
+    //this buffer will generate a depth texture from the perspective of the light source.
+    VkFramebufferCreateInfo create_info{};
+    create_info.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
+    create_info.renderPass = render_pass; //may have to change this not sure
+    create_info.attachmentCount = 1;
+    create_info.pAttachments = &shadow_pass_texture.imageView; //create_image here to store depth data.
+}
+
 void GraphicsImpl::create_frame_buffers() {
     //get the number of images we need to create framebuffers for
     size_t imageNum = swapchain_images.size();
@@ -191,6 +200,44 @@ void GraphicsImpl::create_colour_image_views() {
     }
 }
 
+void GraphicsImpl::create_shadowpass() {
+    VkAttachmentDescription shadowpass_attachment{};
+    shadowpass_attachment.format = VK_FORMAT_D16_UNORM;//format must be a depth/stencil format
+    shadowpass_attachment.samples = VK_SAMPLE_COUNT_1_BIT;
+    shadowpass_attachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
+    shadowpass_attachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
+    shadowpass_attachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
+    shadowpass_attachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
+
+    shadowpass_attachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
+    shadowpass_attachment.finalLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;
+
+    VkAttachmentReference shadowpass_ref{};
+    shadowpass_ref.attachment = 0;
+    shadowpass_ref.layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;
+
+    VkSubpassDescription shadowpass{};
+    shadowpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
+    shadowpass.colorAttachmentCount = 0;
+    shadowpass.pDepthStencilAttachment = &shadowpass_ref;
+    
+    VkRenderPassCreateInfo createInfo{};
+    createInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
+    createInfo.attachmentCount = 1;
+    VkAttachmentDescription attachments[1] = { shadowpass_attachment };
+    createInfo.pAttachments = attachments;
+    createInfo.subpassCount = 1;
+    VkSubpassDescription subpasses[1] = {shadowpass};
+    createInfo.pSubpasses = subpasses;
+    //createInfo.dependencyCount = 1;
+    //createInfo.pDependencies = &dependency;
+
+
+    if (vkCreateRenderPass(device, &createInfo, nullptr, &render_pass) != VK_SUCCESS) {
+        throw std::runtime_error("could not create render pass");
+    }
+}
+
 void GraphicsImpl::create_render_pass() {
     //create a depth attachment and a depth subpass
     VkAttachmentDescription depthAttachment{};
@@ -240,10 +287,6 @@ void GraphicsImpl::create_render_pass() {
     //our framebuffer only has a color buffer attached to it so this layout will help optimize it
     colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
 
-    VkSubpassDescription depthSubpass{};
-    depthSubpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
-    depthSubpass.pDepthStencilAttachment = &depthAttachmentRef;
-
     //creating the actual subpass using the reference we created above
     VkSubpassDescription colorSubpass{};
     colorSubpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
@@ -257,7 +300,7 @@ void GraphicsImpl::create_render_pass() {
     VkAttachmentDescription attachments[2] = { colorAttachment, depthAttachment };
     createInfo.pAttachments = attachments;
     createInfo.subpassCount = 1;
-    VkSubpassDescription subpasses[1] = { colorSubpass };
+    VkSubpassDescription subpasses[1] = {colorSubpass};
     createInfo.pSubpasses = subpasses;
     //createInfo.dependencyCount = 1;
     //createInfo.pDependencies = &dependency;
@@ -798,7 +841,7 @@ void GraphicsImpl::create_command_buffers(std::vector<GameObject*> game_objects)
         renderArea.extent = swapchain_extent;
         renderInfo.renderArea = renderArea;
 
-        const size_t size_of_array = 2;
+        const size_t size_of_array = 3;
         std::vector<VkClearValue> clear_values;
 
         VkClearValue color_clear;
@@ -821,7 +864,7 @@ void GraphicsImpl::create_command_buffers(std::vector<GameObject*> game_objects)
         //vkCmdNextSubpass(commandBuffers[i], VK_SUBPASS_CONTENTS_INLINE);
 
         //add commands to command buffer
-        vkCmdBindPipeline(command_buffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, graphics_pipeline);
+      vkCmdBindPipeline(command_buffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, graphics_pipeline);
 
         VkViewport newViewport = {};
         newViewport.x = 0;
@@ -955,9 +998,6 @@ void GraphicsImpl::update_vertex_buffer(std::vector<Vertex> vertex_data) {
     mem::createBuffer(physical_device, device, &temp_info, &temp_buffer);
 
     //map data to temp buffer
-    for (size_t i = 0; i < vertex_data.size(); i++) {
-        printf("vertex_data: <%f, %f, %f> \n", vertex_data[i].position.x, vertex_data[i].position.y, vertex_data[i].position.z);
-    }
     mem::allocateMemory(sizeof(vertex_data[0]) * vertex_data.size(), &temp_buffer);
    
     /* THIS CODE FOR SURE WORKS*/
diff --git a/lib/memory_allocator.cpp b/lib/memory_allocator.cpp
index 554af1e..fa48a2c 100644
--- a/lib/memory_allocator.cpp
+++ b/lib/memory_allocator.cpp
@@ -4,7 +4,73 @@
 #include <cstring>
 using namespace mem;
 
+StackBuffer::StackBuffer(VkPhysicalDevice physical_device, VkDevice device, BufferCreateInfo* p_buffer_info) {
+    //create buffer 
+    VkBufferCreateInfo createInfo{};
+    createInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
+    createInfo.pNext = p_buffer_info->pNext;
+    createInfo.flags = p_buffer_info->flags;
+    createInfo.usage = p_buffer_info->usage;
+    createInfo.size = p_buffer_info->size;
+    createInfo.sharingMode = p_buffer_info->sharingMode;
+    createInfo.queueFamilyIndexCount = p_buffer_info->queueFamilyIndexCount;
+    createInfo.pQueueFamilyIndices = p_buffer_info->pQueueFamilyIndices;
+
+    if (vkCreateBuffer(device, &createInfo, nullptr, &buffer) != VK_SUCCESS) {
+        throw std::runtime_error("could not create buffer");
+    };
+
+    //allocate desired memory to buffer
+    VkMemoryRequirements memRequirements;
+    vkGetBufferMemoryRequirements(device, buffer, &memRequirements);
+
+    //allocate memory for buffer
+    VkMemoryAllocateInfo memoryInfo{};
+    memoryInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
+    memoryInfo.allocationSize = memRequirements.size;
+    //too lazy to even check if this exists will do later TODO
+    memoryInfo.memoryTypeIndex = findMemoryType(physical_device, memRequirements.memoryTypeBits, p_buffer_info->memoryProperties);
+
+    VkResult allocResult = vkAllocateMemory(device, &memoryInfo, nullptr, &buffer_memory);
 
+    if (allocResult != VK_SUCCESS) {
+        throw std::runtime_error("could not allocate memory for memory pool");
+    }
+
+    if (vkBindBufferMemory(device, buffer, buffer_memory, 0) != VK_SUCCESS) {
+        throw std::runtime_error("could not bind allocated memory to buffer");
+    }
+
+    buffer_size = p_buffer_info->size;
+    offset = 0;
+}
+
+VkDeviceSize StackBuffer::allocate(VkDeviceSize allocation_size) {
+    if (allocation_size > buffer_size) {
+        //not sure how to handle this case right now
+        printf("COULD ALLOCATE INTO BUFFER, OUT OF SPACE \n");
+        return 0;
+    }
+    buffer_size -= allocation_size;
+    VkDeviceSize push_to = offset;
+    offset += allocation_size;
+    allocations.push_back(allocation_size);
+
+    return push_to;
+}
+
+void StackBuffer::free(VkDeviceSize delete_offset) {
+    //the only thing the user would have at this point is the offset
+    VkDeviceSize current_offset = 0;
+    for (auto it = allocations.begin(); it != allocations.end(); it++) {
+        if (delete_offset == current_offset) {
+            //delete at location
+            allocations.erase(it);
+            break;
+        }
+        current_offset += *it;
+    }
+}
 
 Pool::Pool(VkDevice device, PoolCreateInfo create_info) {
     pool_create_info = create_info;
diff --git a/lib/model.cpp b/lib/model.cpp
index 9dc785d..c635619 100644
--- a/lib/model.cpp
+++ b/lib/model.cpp
@@ -8,14 +8,19 @@ using namespace tuco;
 void Model::add_mesh(const std::string& fileName) {
 	//have assimp read file
 	Assimp::Importer importer;
-	
+
+	auto t1 = std::chrono::high_resolution_clock::now();
 	const aiScene* scene = importer.ReadFile(fileName,
 		aiProcess_GenNormals |
 		aiProcess_CalcTangentSpace |
 		aiProcess_JoinIdenticalVertices |
 		aiProcess_Triangulate |
 		aiProcess_SortByPType);
+	auto t2 = std::chrono::high_resolution_clock::now();
 
+	std::chrono::duration<double, std::milli> final_count = t2 - t1;
+	printf("assimp time: %f \n", final_count.count());
+	
 	if (!scene) {
 		printf("[ERROR] - Mode::add_mesh() : given model data could not be read");
 		throw std::runtime_error("");
diff --git a/main.cpp b/main.cpp
index 4cd8ee8..41b99c3 100644
--- a/main.cpp
+++ b/main.cpp
@@ -30,21 +30,22 @@ int main() {
 	glm::vec3 camera_face = glm::vec3(0.0, 0.0, -1.0);
 	glm::vec3 camera_orientation = glm::vec3(0.0, -1.0, 0.0);
 
-	tuco::Camera* main_camera = antuco.create_camera(camera_pos, camera_face, camera_orientation, glm::radians(45.0f), 0.1f, 150.0f);
+	tuco::Camera* main_camera = antuco.create_camera(camera_pos, camera_face, camera_orientation, glm::radians(45.0f), 0.01f, 150.0f);
 
 	//create some light for the scene
-	tuco::Light* light = antuco.create_light(glm::vec3(1.0f, 3.0f, 3.0f), glm::vec3(1.0, 1.0, 1.0));
+	tuco::Light* light = antuco.create_light(glm::vec3(0.0f, 5.0f, 0.0f), glm::vec3(1.0, 1.0, 1.0));
 
 	//create a simple game object
 	tuco::GameObject* some_object = antuco.create_object();
 
 	auto t1 = TIME_IT;
 	some_object->add_mesh("objects/test_object/with_texture.obj"); //will hope texture data is located within model data.
+	some_object->scale(glm::vec3(0.1, 0.1, 0.1));
 	auto t2 = TIME_IT;
 
 	std::chrono::duration<double, std::milli> final_count = t2 - t1;
 	printf("time to load model: %f \n", final_count.count());
-
+	
 	//basic game loop
 	bool game_loop = true;
 
